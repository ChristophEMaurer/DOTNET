using System;
using System.Numerics;
using System.Globalization;

namespace BitcoinLib
{
    /// <summary>
    /// S256Field should really be called S256FieldElement, but we want the same name as in the code in the book.
    /// </summary>
    public class S256Field : FieldElement
    {
        /// <summary>
        /// y^2 = x^3 + ax + b
        /// </summary>
        public const int A = 0;

        /// <summary>
        /// y^2 = x^3 + ax + b
        /// </summary>
        public const int B = 7;

        /// <summary>
        /// P is the prime for bitcoin and is close to 2^256
        /// </summary>
        public static BigInteger P = BigInteger.Pow(2, 256) - BigInteger.Pow(2, 32) - 977;

        /// <summary>
        /// N is the order of the group generated by G: N * G = infinity or 0
        /// </summary>
        public static BigInteger N = BigInteger.Parse("0fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", NumberStyles.AllowHexSpecifier);

        /// <summary>
        /// G is a random point on the curve y^2 = x^3 + 7
        /// </summary>
        public static S256Point G = new S256Point(
            BigInteger.Parse("079be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", NumberStyles.AllowHexSpecifier),
            BigInteger.Parse("0483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", NumberStyles.AllowHexSpecifier));

        public S256Field(BigInteger num) :
            base(num, P)
        {
        }

        public override string ToString()
        {
            string text = string.Format("{0,64}", _num);
            return text;
        }

        public override FieldElement OperatorPlus(FieldElement b)
        {
            if (_prime != b._prime)
            {
                string text = string.Format("Cannot add two number in different fields {0}-{1}", _prime, b._prime);
                throw new TypeErrorException(text);
            }
            if (_prime != S256Field.P)
            {
                string text = string.Format("prime {0} of S256Field must be P ({1})", _prime, S256Field.P);
                throw new TypeErrorException(text);
            }

            BigInteger num;
            num = FieldElement.Mod(_num + b._num, _prime);

            S256Field c = new S256Field(num);
            return c;
        }


        public static S256Field operator +(S256Field a, S256Field b)
        {
            FieldElement x = a.OperatorPlus(b);

            S256Field y = (S256Field)x;

            return y;
        }

        public S256Field Sqrt()
        {
            // python uses the // operator which is floor: 15 // 4 = 3,75 -> 3

            //
            // how to do a BigInteger exp BigInteger
            //
            S256Field x = OperatorPow((S256Field.P + 1) / 4);

            return x;
        }

        new public S256Field OperatorPow(BigInteger exponent)
        {
            BigInteger num;

            //int n = (int)FieldElement.Mod(exponent, _prime - 1);
            BigInteger n = FieldElement.Mod(exponent, _prime - 1);
            num = BigInteger.ModPow(_num, n, _prime);

            S256Field c = new S256Field(num);
            return c;
        }
    }
}
